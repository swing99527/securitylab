// API æ¨¡å—å…¥å£ - ç»Ÿä¸€å¯¼å‡ºæ‰€æœ‰æ¥å£æ–¹æ³•

import type {
  ApiResponse,
  PaginatedResponse,
  // ç”¨æˆ·
  User,
  LoginRequest,
  LoginResponse,
  // é¡¹ç›®
  Project,
  ProjectListParams,
  // ä»»åŠ¡
  Task,
  TaskDetail,
  TaskListParams,
  // æŠ¥å‘Š
  Report,
  ReportListParams,
  ReportAnnotation,
  ReportReviewRequest,
  ReportSignRequest,
  // æ ·å“
  Sample,
  SampleDetail,
  SampleListParams,
  SampleIntakeRequest,
  SampleCheckoutRequest,
  SampleReturnRequest,
  // åˆè§„
  ComplianceItem,
  ComplianceUpdateRequest,
  // ä»ªè¡¨ç›˜
  DashboardStats,
  HeatmapData,
  VulnerabilityTrendData,
  TodoItem,
  // é€šçŸ¥
  Notification,
  // ç¡¬ä»¶
  HardwareStatus,
  // Fuzzing
  FuzzingStats,
  FuzzingCoverage,
  // ç½‘ç»œæ‹“æ‰‘
  NetworkTopology,
  // çŸ¥è¯†åº“
  KnowledgeCategory,
  Article,
  ArticleListParams,
  CreateArticleRequest,
  UpdateArticleRequest,
  ReadingHistory,
} from "./types"

import {
  mockTasks,
  mockProjects,
  mockReports,
  mockAnnotations,
  mockSamples,
  mockSampleFlows,
  mockComplianceData,
  mockDashboardStats,
  mockHeatmapData,
  mockVulnerabilityTrend,
  mockTodoItems,
  mockNotifications,
  mockVulnerabilities,
  mockAssets,
  mockTaskLogs,
  mockFuzzingStats,
  mockFuzzingCoverage,
  mockNetworkTopology,
  mockKnowledgeCategories,
  mockArticles,
  mockReadingHistory,
  mockStarredArticles,
} from "./mock-data"

import {
  adaptPaginatedResponse,
  adaptAuthResponse,
  adaptProjectDetail,
  adaptSampleDetail,
  adaptTaskDetail,
  handleApiError,
} from "./adapter"

// ==================== é…ç½® ====================
const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || "http://localhost:8000"
const USE_MOCK = process.env.NEXT_PUBLIC_USE_MOCK === "true"

// Debug logging
console.log("ğŸ” API Configuration:", {
  API_BASE_URL,
  USE_MOCK,
  ENV_VALUE: process.env.NEXT_PUBLIC_USE_MOCK,
})
// æ¨¡æ‹Ÿå»¶è¿Ÿ
const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))

// é€šç”¨è¯·æ±‚æ–¹æ³•ï¼ˆç”Ÿäº§ç¯å¢ƒä½¿ç”¨ï¼‰
async function request<T>(endpoint: string, options?: RequestInit): Promise<any> {
  try {
    // ä»localStorageè·å–token
    const token = typeof window !== "undefined" ? localStorage.getItem("token") : null

    const response = await fetch(`${API_BASE_URL}${endpoint}`, {
      method: 'GET', // Default method
      ...options, // Spread options to override defaults
      headers: {
        "Content-Type": "application/json",
        ...(token && { Authorization: `Bearer ${token}` }),
        ...options?.headers, // Merge custom headers
      },
    })

    if (!response.ok) {
      const error = await response.json().catch(() => ({}))

      // å¤„ç†401æœªæˆæƒé”™è¯¯ - è‡ªåŠ¨è·³è½¬åˆ°ç™»å½•é¡µ
      if (response.status === 401) {
        if (typeof window !== "undefined") {
          // æ¸…é™¤token
          localStorage.removeItem("token")
          localStorage.removeItem("user")

          // è·³è½¬åˆ°ç™»å½•é¡µ
          window.location.href = "/login"
        }
        throw new Error("ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•")
      }

      throw new Error(error.detail || `HTTP ${response.status}`)
    }

    return response.json()
  } catch (error) {
    throw error
  }
}

// ==================== ç”¨æˆ·ç›¸å…³æ¥å£ ====================
export const authApi = {
  // ç™»å½•
  async login(data: LoginRequest): Promise<ApiResponse<LoginResponse>> {
    if (USE_MOCK) {
      await delay(500)
      return {
        code: 200,
        message: "success",
        data: {
          token: "mock-token-" + Date.now(),
          user: {
            id: "user-001",
            name: "å¼ å·¥ç¨‹å¸ˆ",
            role: "engineer",
            status: "idle",
            email: "zhang@example.com",
          },
        },
      }
    }

    try {
      const response = await request("/api/v1/auth/login", {
        method: "POST",
        body: JSON.stringify({ email: data.email, password: data.password }),
      })
      return adaptAuthResponse(response)
    } catch (error) {
      return handleApiError(error)
    }
  },

  // è·å–å½“å‰ç”¨æˆ·
  async getCurrentUser(): Promise<ApiResponse<User>> {
    if (USE_MOCK) {
      await delay(200)
      return {
        code: 200,
        message: "success",
        data: {
          id: "user-001",
          name: "å¼ å·¥ç¨‹å¸ˆ",
          role: "engineer",
          status: "idle",
          email: "zhang@example.com",
        },
      }
    }

    try {
      const response = await request("/api/v1/auth/me")
      return {
        code: 200,
        message: "success",
        data: response,
      }
    } catch (error) {
      return handleApiError(error)
    }
  },

  // ç™»å‡º
  async logout(): Promise<ApiResponse<null>> {
    await delay(200)
    if (typeof window !== "undefined") {
      localStorage.removeItem("token")
    }
    return { code: 200, message: "success", data: null }
  },
}

// ==================== é¡¹ç›®ç›¸å…³æ¥å£ ====================
export const projectApi = {
  // è·å–é¡¹ç›®åˆ—è¡¨
  async getList(params?: ProjectListParams): Promise<ApiResponse<PaginatedResponse<Project>>> {
    if (USE_MOCK) {
      await delay(300)
      let list = [...mockProjects]
      if (params?.status) {
        list = list.filter((p) => p.status === params.status)
      }
      if (params?.keyword) {
        const kw = params.keyword.toLowerCase()
        list = list.filter((p) => p.name.toLowerCase().includes(kw) || p.id.toLowerCase().includes(kw))
      }
      return {
        code: 200,
        message: "success",
        data: {
          list,
          total: list.length,
          page: params?.page || 1,
          pageSize: params?.pageSize || 10,
        },
      }
    }

    try {
      const query = new URLSearchParams({
        ...(params?.status && { status_filter: params.status }),
        ...(params?.keyword && { search: params.keyword }),
        page: String(params?.page || 1),
        page_size: String(params?.pageSize || 20),
      })

      const response = await request(`/api/v1/projects?${query}`)
      return adaptPaginatedResponse<Project>(response)
    } catch (error) {
      return handleApiError(error)
    }
  },

  // è·å–é¡¹ç›®è¯¦æƒ…
  async getDetail(id: string): Promise<ApiResponse<Project>> {
    if (USE_MOCK) {
      await delay(200)
      const project = mockProjects.find((p) => p.id === id)
      if (!project) {
        return { code: 404, message: "é¡¹ç›®ä¸å­˜åœ¨", data: null as unknown as Project }
      }
      return { code: 200, message: "success", data: project }
    }

    try {
      const response = await request(`/api/v1/projects/${id}`)
      return {
        code: 200,
        message: "success",
        data: adaptProjectDetail(response),
      }
    } catch (error) {
      return handleApiError(error)
    }
  },
}

// ==================== ä»»åŠ¡ç›¸å…³æ¥å£ ====================
export const taskApi = {
  // è·å–ä»»åŠ¡åˆ—è¡¨
  async getList(params?: TaskListParams): Promise<ApiResponse<PaginatedResponse<Task>>> {
    if (USE_MOCK) {
      await delay(300)
      let list = [...mockTasks]
      if (params?.status) {
        list = list.filter((t) => t.status === params.status)
      }
      if (params?.projectId) {
        list = list.filter((t) => t.projectId === params.projectId)
      }
      if (params?.keyword) {
        const kw = params.keyword.toLowerCase()
        list = list.filter((t) => t.name.toLowerCase().includes(kw) || t.id.toLowerCase().includes(kw))
      }
      return {
        code: 200,
        message: "success",
        data: {
          list,
          total: list.length,
          page: params?.page || 1,
          pageSize: params?.pageSize || 10,
        },
      }
    }

    try {
      const query = new URLSearchParams({
        ...(params?.status && { status_filter: params.status }),
        ...(params?.type && { type_filter: params.type }),
        ...(params?.projectId && { project_id: params.projectId }),
        ...(params?.keyword && { search: params.keyword }),
        page: String(params?.page || 1),
        page_size: String(params?.pageSize || 20),
      })

      const response = await request(`/api/v1/tasks?${query}`)
      return adaptPaginatedResponse<Task>(response)
    } catch (error) {
      return handleApiError(error)
    }
  },

  // è·å–ä»»åŠ¡è¯¦æƒ…
  async getDetail(id: string): Promise<ApiResponse<TaskDetail>> {
    if (USE_MOCK) {
      await delay(200)
      const task = mockTasks.find((t) => t.id === id)
      if (!task) {
        return { code: 404, message: "ä»»åŠ¡ä¸å­˜åœ¨", data: null as unknown as TaskDetail }
      }
      return {
        code: 200,
        message: "success",
        data: {
          ...task,
          logs: mockTaskLogs,
          vulnerabilities: mockVulnerabilities,
          assets: mockAssets,
        },
      }
    }

    try {
      const response = await request(`/api/v1/tasks/${id}`)
      return {
        code: 200,
        message: "success",
        data: adaptTaskDetail(response),
      }
    } catch (error) {
      return handleApiError(error)
    }
  },

  // åˆ›å»ºä»»åŠ¡
  async create(data: any): Promise<ApiResponse<Task>> {
    try {
      const response = await request('/api/v1/tasks', {
        method: 'POST',
        body: JSON.stringify(data)
      })
      return {
        code: 201,
        message: 'success',
        data: response
      }
    } catch (error) {
      return handleApiError(error)
    }
  },

  async execute(id: string, force: boolean = false): Promise<ApiResponse<any>> {
    return request(`/api/v1/tasks/${id}/execute`, {
      method: 'POST',
      body: JSON.stringify({ force }),
    })
  },

  async delete(id: string): Promise<ApiResponse<void>> {
    return request(`/api/v1/tasks/${id}`, {
      method: 'DELETE',
    })
  },

  // æš‚åœä»»åŠ¡
  async pause(id: string): Promise<ApiResponse<Task>> {
    if (USE_MOCK) {
      await delay(300)
      const task = mockTasks.find((t) => t.id === id)
      if (task) task.status = "paused"
      return { code: 200, message: "success", data: task! }
    }

    try {
      const response = await request(`/api/v1/tasks/${id}`, {
        method: "PATCH",
        body: JSON.stringify({ status: "paused" }),
      })
      return { code: 200, message: "success", data: response }
    } catch (error) {
      return handleApiError(error)
    }
  },

  // æ¢å¤ä»»åŠ¡
  async resume(id: string): Promise<ApiResponse<Task>> {
    if (USE_MOCK) {
      await delay(300)
      const task = mockTasks.find((t) => t.id === id)
      if (task) task.status = "running"
      return { code: 200, message: "success", data: task! }
    }

    try {
      const response = await request(`/api/v1/tasks/${id}`, {
        method: "PATCH",
        body: JSON.stringify({ status: "running" }),
      })
      return { code: 200, message: "success", data: response }
    } catch (error) {
      return handleApiError(error)
    }
  },

  // åœæ­¢ä»»åŠ¡
  async stop(id: string): Promise<ApiResponse<Task>> {
    if (USE_MOCK) {
      await delay(300)
      const task = mockTasks.find((t) => t.id === id)
      if (task) task.status = "completed"
      return { code: 200, message: "success", data: task! }
    }

    try {
      const response = await request(`/api/v1/tasks/${id}`, {
        method: "PATCH",
        body: JSON.stringify({ status: "cancelled" }),
      })
      return { code: 200, message: "success", data: response }
    } catch (error) {
      return handleApiError(error)
    }
  },

  // è·å–ä»»åŠ¡æ—¥å¿—
  async getLogs(id: string, params?: { limit?: number; level?: string }): Promise<ApiResponse<{ task_id: string; total: number; logs: any[] }>> {
    try {
      const queryParams = new URLSearchParams()
      if (params?.limit) queryParams.append('limit', params.limit.toString())
      if (params?.level) queryParams.append('level', params.level)

      const url = `/api/v1/tasks/${id}/logs${queryParams.toString() ? '?' + queryParams.toString() : ''}`
      const response = await request(url)

      return {
        code: response.code || 200,
        message: response.message || 'success',
        data: response.data
      }
    } catch (error) {
      return handleApiError(error)
    }
  },

  // è·å– Fuzzing ç»Ÿè®¡
  async getFuzzingStats(id: string): Promise<ApiResponse<FuzzingStats>> {
    await delay(100)
    return { code: 200, message: "success", data: mockFuzzingStats }
  },

  // è·å– Fuzzing è¦†ç›–ç‡å†å²
  async getFuzzingCoverage(id: string): Promise<ApiResponse<FuzzingCoverage[]>> {
    await delay(100)
    return { code: 200, message: "success", data: mockFuzzingCoverage }
  },

  // è·å–ç½‘ç»œæ‹“æ‰‘
  async getNetworkTopology(id: string): Promise<ApiResponse<NetworkTopology>> {
    await delay(200)
    return { code: 200, message: "success", data: mockNetworkTopology }
  },

  // è·å–ä»»åŠ¡å®æ—¶çŠ¶æ€ï¼ˆä»Redisï¼‰
  async getStatus(id: string): Promise<ApiResponse<any>> {
    try {
      const response = await request(`/api/v1/tasks/${id}/status`)
      return {
        code: 200,
        message: "success",
        data: response
      }
    } catch (error) {
      return handleApiError(error)
    }
  },
}

// ==================== æŠ¥å‘Šç›¸å…³æ¥å£ ====================
export const reportApi = {

  // åˆ›å»ºæŠ¥å‘Š

    return {
      code: 201,
      message: "success",
      data: {
        ...response,
        projectName: response.project_name,
        authorId: response.author_id,
        reviewerId: response.reviewer_id,
        createdAt: response.created_at,
        updatedAt: response.updated_at,
        approvedAt: response.approved_at,
        content: response.content
      }
    }
  },
  // è·å–æŠ¥å‘Šåˆ—è¡¨
  async getList(params?: ReportListParams): Promise<ApiResponse<PaginatedResponse<Report>>> {
    if (USE_MOCK) {
      await delay(300)
      let list = [...mockReports]
      if (params?.status) {
        list = list.filter((r) => r.status === params.status)
      }
      if (params?.projectId) {
        list = list.filter((r) => r.projectId === params.projectId)
      }
      if (params?.keyword) {
        const kw = params.keyword.toLowerCase()
        list = list.filter((r) => r.title.toLowerCase().includes(kw) || r.id.toLowerCase().includes(kw))
      }
      return {
        code: 200,
        message: "success",
        data: {
          list,
          total: list.length,
          page: params?.page || 1,
          pageSize: params?.pageSize || 10,
        },
      }
    }

    // çœŸå®APIè°ƒç”¨
    const queryParams = new URLSearchParams()
    if (params?.page) queryParams.append("page", params.page.toString())
    if (params?.pageSize) queryParams.append("page_size", params.pageSize.toString())
    if (params?.status) queryParams.append("status_filter", params.status)
    if (params?.projectId) queryParams.append("project_id", params.projectId)
    if (params?.keyword) queryParams.append("search", params.keyword)

    const response = await request(`/api/v1/reports?${queryParams}`)
    return adaptPaginatedResponse(response)
  },

  // è·å–æŠ¥å‘Šè¯¦æƒ…
  async getDetail(id: string): Promise<ApiResponse<Report>> {
    if (USE_MOCK) {
      await delay(200)
      const report = mockReports.find((r) => r.id === id)
      if (!report) {
        return { code: 404, message: "æŠ¥å‘Šä¸å­˜åœ¨", data: null as unknown as Report }
      }
      return { code: 200, message: "success", data: report }
    }

    // çœŸå®APIè°ƒç”¨
    const response = await request(`/api/v1/reports/${id}`)

    // è½¬æ¢responseçš„é”®ä»snake_caseåˆ°camelCase
    const transformedData = {
      ...response,
      projectName: response.project_name,
      authorId: response.author_id,
      reviewerId: response.reviewer_id,
      createdAt: response.created_at,
      updatedAt: response.updated_at,
      approvedAt: response.approved_at,
      // contentä¿æŒåŸæ ·,å› ä¸ºå®ƒæ˜¯JSONBï¼Œsectionså·²ç»åœ¨é‡Œé¢äº†
      content: response.content
    }

    return {
      code: 200,
      message: "success",
      data: transformedData
    }
  },

  // è·å–æŠ¥å‘Šæ‰¹æ³¨
  async getAnnotations(reportId: string): Promise<ApiResponse<ReportAnnotation[]>> {
    await delay(200)
    const annotations = mockAnnotations.filter((a) => a.reportId === reportId)
    return { code: 200, message: "success", data: annotations }
  },

  // æ·»åŠ æ‰¹æ³¨
  async addAnnotation(
    reportId: string,
    data: { sectionId: string; content: string },
  ): Promise<ApiResponse<ReportAnnotation>> {
    await delay(300)
    const newAnnotation: ReportAnnotation = {
      id: "ann-" + Date.now(),
      reportId,
      sectionId: data.sectionId,
      content: data.content,
      author: "å½“å‰ç”¨æˆ·",
      authorId: "user-001",
      createdAt: new Date().toISOString(),
      resolved: false,
      replies: [],
    }
    return { code: 200, message: "success", data: newAnnotation }
  },

  // æäº¤å®¡æ ¸
  async submitForReview(id: string): Promise<ApiResponse<Report>> {
    await delay(300)
    const report = mockReports.find((r) => r.id === id)
    if (report) report.status = "pending_review"
    return { code: 200, message: "success", data: report! }
  },

  // å®¡æ ¸æŠ¥å‘Š
  async review(id: string, data: ReportReviewRequest): Promise<ApiResponse<Report>> {
    await delay(300)
    const report = mockReports.find((r) => r.id === id)
    if (report) {
      report.status = data.action === "approve" ? "approved" : "rejected"
    }
    return { code: 200, message: "success", data: report! }
  },

  // ç”µå­ç­¾ç« 
  async sign(id: string, data: ReportSignRequest): Promise<ApiResponse<Report>> {
    await delay(500)
    // æ¨¡æ‹Ÿå¯†ç éªŒè¯
    if (data.password !== "123456") {
      return { code: 401, message: "å¯†ç é”™è¯¯", data: null as unknown as Report }
    }
    const report = mockReports.find((r) => r.id === id)
    if (report) report.status = "signed"
    return { code: 200, message: "ç­¾ç½²æˆåŠŸ", data: report! }
  },

  // æ›´æ–°ç« èŠ‚å†…å®¹
  async updateSection(
    reportId: string,
    sectionId: string,
    content: string
  ): Promise<ApiResponse<any>> {
    if (USE_MOCK) {
      await delay(500)
      return { code: 200, message: "success", data: { success: true } }
    }

    // çœŸå®APIè°ƒç”¨
    const response = await request(`/api/v1/reports/${reportId}/sections/${sectionId}`, {
      method: 'PATCH',
      body: JSON.stringify({ content }),
    })

    return {
      code: 200,
      message: "success",
      data: response
    }
  },

  // å¯¼å‡ºPDF
  async exportPdf(id: string): Promise<Blob> {
    await delay(1000)
    // æ¨¡æ‹Ÿè¿”å› PDF Blob
    return new Blob(["PDF content"], { type: "application/pdf" })
  },
}

// ==================== æ ·å“ç›¸å…³æ¥å£ ====================
export const sampleApi = {
  // è·å–æ ·å“åˆ—è¡¨
  async getList(params?: SampleListParams): Promise<ApiResponse<PaginatedResponse<Sample>>> {
    if (USE_MOCK) {
      await delay(300)
      let list = [...mockSamples]
      if (params?.status) {
        list = list.filter((s) => s.status === params.status)
      }
      if (params?.location) {
        list = list.filter((s) => s.location.includes(params.location!))
      }
      if (params?.keyword) {
        const kw = params.keyword.toLowerCase()
        list = list.filter(
          (s) =>
            s.name.toLowerCase().includes(kw) || s.id.toLowerCase().includes(kw) || s.model.toLowerCase().includes(kw),
        )
      }
      return {
        code: 200,
        message: "success",
        data: {
          list,
          total: list.length,
          page: params?.page || 1,
          pageSize: params?.pageSize || 10,
        },
      }
    }

    try {
      const query = new URLSearchParams({
        ...(params?.status && { status_filter: params.status }),
        ...(params?.location && { search: params.location }),
        ...(params?.keyword && { search: params.keyword }),
        page: String(params?.page || 1),
        page_size: String(params?.pageSize || 20),
      })

      const response = await request(`/api/v1/samples?${query}`)
      return adaptPaginatedResponse<Sample>(response)
    } catch (error) {
      return handleApiError(error)
    }
  },

  // è·å–æ ·å“è¯¦æƒ…ï¼ˆå«æµè½¬è®°å½•ï¼‰
  async getDetail(id: string): Promise<ApiResponse<SampleDetail>> {
    if (USE_MOCK) {
      await delay(200)
      const sample = mockSamples.find((s) => s.id === id)
      if (!sample) {
        return { code: 404, message: "æ ·å“ä¸å­˜åœ¨", data: null as unknown as SampleDetail }
      }
      const flows = mockSampleFlows.filter((f) => f.sampleId === id)
      return { code: 200, message: "success", data: { ...sample, flows } }
    }

    try {
      const response = await request(`/api/v1/samples/${id}`)
      return {
        code: 200,
        message: "success",
        data: {
          ...adaptSampleDetail(response),
          flows: [], // æµè½¬è®°å½•æš‚æ—¶ä¸ºç©ºï¼Œåç»­å¯ä»åç«¯è·å–
        },
      }
    } catch (error) {
      return handleApiError(error)
    }
  },

  // æ ·å“å…¥åº“
  async intake(data: SampleIntakeRequest): Promise<ApiResponse<Sample>> {
    if (USE_MOCK) {
      await delay(500)
      const newSample: Sample = {
        id: "SPL-" + Date.now(),
        ...data,
        status: "in_stock",
        inDate: new Date().toISOString().split("T")[0],
        lastUpdated: new Date().toISOString().split("T")[0],
      }
      return { code: 200, message: "success", data: newSample }
    }

    try {
      const response = await request(`/api/v1/samples`, {
        method: "POST",
        body: JSON.stringify(data),
      })
      return { code: 200, message: "success", data: response }
    } catch (error) {
      return handleApiError(error)
    }
  },

  // æ ·å“é¢†ç”¨
  async checkout(data: SampleCheckoutRequest): Promise<ApiResponse<Sample>> {
    await delay(300)
    const sample = mockSamples.find((s) => s.id === data.sampleId)
    if (sample) {
      sample.status = "in_use"
      sample.projectId = data.projectId
    }
    return { code: 200, message: "success", data: sample! }
  },

  // æ ·å“å½’è¿˜
  async returnSample(data: SampleReturnRequest): Promise<ApiResponse<Sample>> {
    await delay(300)
    const sample = mockSamples.find((s) => s.id === data.sampleId)
    if (sample) {
      sample.status = "in_stock"
      sample.location = data.location
      sample.currentHolder = undefined
      sample.projectId = undefined
    }
    return { code: 200, message: "success", data: sample! }
  },

  // æ ·å“æŠ¥åºŸ
  async scrap(id: string, reason: string): Promise<ApiResponse<Sample>> {
    if (USE_MOCK) {
      await delay(300)
      const sample = mockSamples.find((s) => s.id === id)
      if (sample) {
        sample.status = "scrapped"
        sample.location = "æŠ¥åºŸåŒº"
      }
      return { code: 200, message: "success", data: sample! }
    }

    try {
      const response = await request(`/api/v1/samples/${id}`, {
        method: "DELETE",
      })
      return { code: 200, message: "success", data: response }
    } catch (error) {
      return handleApiError(error)
    }
  },

  // æ‰«ç æŸ¥è¯¢
  async scanQuery(code: string): Promise<ApiResponse<Sample>> {
    await delay(200)
    // æ¨¡æ‹Ÿé€šè¿‡äºŒç»´ç æˆ–æ¡ç æŸ¥è¯¢æ ·å“
    const sample = mockSamples.find((s) => s.id === code || s.serialNumber === code)
    if (!sample) {
      return { code: 404, message: "æ ·å“ä¸å­˜åœ¨", data: null as unknown as Sample }
    }
    return { code: 200, message: "success", data: sample }
  },

  // è·å–ç»Ÿè®¡æ•°æ®
  async getStats(): Promise<
    ApiResponse<{ total: number; inStock: number; inUse: number; returned: number; scrapped: number }>
  > {
    await delay(100)
    return {
      code: 200,
      message: "success",
      data: {
        total: mockSamples.length,
        inStock: mockSamples.filter((s) => s.status === "in_stock").length,
        inUse: mockSamples.filter((s) => s.status === "in_use").length,
        returned: mockSamples.filter((s) => s.status === "returned").length,
        scrapped: mockSamples.filter((s) => s.status === "scrapped").length,
      },
    }
  },
}

// ==================== åˆè§„ç›¸å…³æ¥å£ ====================
export const complianceApi = {
  // è·å–åˆè§„çŸ©é˜µæ•°æ®
  async getMatrix(projectId: string): Promise<ApiResponse<ComplianceItem[]>> {
    await delay(300)
    return { code: 200, message: "success", data: mockComplianceData }
  },

  // æ›´æ–°åˆè§„é¡¹
  async updateItem(data: ComplianceUpdateRequest): Promise<ApiResponse<ComplianceItem>> {
    await delay(300)
    // é€’å½’æŸ¥æ‰¾å¹¶æ›´æ–°
    const findAndUpdate = (items: ComplianceItem[]): ComplianceItem | null => {
      for (const item of items) {
        if (item.id === data.itemId) {
          item.manualResult = data.manualResult
          if (data.evidence) item.evidence = data.evidence
          return item
        }
        if (item.children) {
          const found = findAndUpdate(item.children)
          if (found) return found
        }
      }
      return null
    }
    const updated = findAndUpdate(mockComplianceData)
    return { code: 200, message: "success", data: updated! }
  },

  // æ‰¹é‡é€šè¿‡ç»¿è‰²é¡¹
  async batchPassGreen(projectId: string): Promise<ApiResponse<{ count: number }>> {
    await delay(500)
    let count = 0
    const batchPass = (items: ComplianceItem[]) => {
      for (const item of items) {
        if (item.autoResult === "pass" && item.manualResult === "pending") {
          item.manualResult = "pass"
          count++
        }
        if (item.children) batchPass(item.children)
      }
    }
    batchPass(mockComplianceData)
    return { code: 200, message: "success", data: { count } }
  },

  // è·å–ç»Ÿè®¡æ•°æ®
  async getStats(
    projectId: string,
  ): Promise<ApiResponse<{ total: number; pass: number; fail: number; warning: number; pending: number }>> {
    await delay(100)
    let total = 0,
      pass = 0,
      fail = 0,
      warning = 0,
      pending = 0
    const count = (items: ComplianceItem[]) => {
      for (const item of items) {
        if (!item.children || item.children.length === 0) {
          total++
          if (item.autoResult === "pass") pass++
          if (item.autoResult === "fail") fail++
          if (item.autoResult === "warning") warning++
          if (item.autoResult === "pending") pending++
        }
        if (item.children) count(item.children)
      }
    }
    count(mockComplianceData)
    return { code: 200, message: "success", data: { total, pass, fail, warning, pending } }
  },
}

// ==================== ä»ªè¡¨ç›˜ç›¸å…³æ¥å£ ====================
export const dashboardApi = {
  // è·å–ç»Ÿè®¡æ•°æ®
  async getStats(): Promise<ApiResponse<DashboardStats>> {
    await delay(200)
    return { code: 200, message: "success", data: mockDashboardStats }
  },

  // è·å–çƒ­åŠ›å›¾æ•°æ®
  async getHeatmap(): Promise<ApiResponse<HeatmapData[]>> {
    await delay(300)
    return { code: 200, message: "success", data: mockHeatmapData }
  },

  // è·å–æ¼æ´è¶‹åŠ¿æ•°æ®
  async getVulnerabilityTrend(): Promise<ApiResponse<VulnerabilityTrendData[]>> {
    await delay(200)
    return { code: 200, message: "success", data: mockVulnerabilityTrend }
  },

  // è·å–å¾…åŠäº‹é¡¹
  async getTodos(): Promise<ApiResponse<TodoItem[]>> {
    await delay(200)
    return { code: 200, message: "success", data: mockTodoItems }
  },

  // å®Œæˆå¾…åŠäº‹é¡¹
  async completeTodo(id: string): Promise<ApiResponse<TodoItem>> {
    await delay(200)
    const todo = mockTodoItems.find((t) => t.id === id)
    if (todo) todo.completed = true
    return { code: 200, message: "success", data: todo! }
  },
}

// ==================== é€šçŸ¥ç›¸å…³æ¥å£ ====================
export const notificationApi = {
  // è·å–é€šçŸ¥åˆ—è¡¨
  async getList(): Promise<ApiResponse<Notification[]>> {
    await delay(200)
    return { code: 200, message: "success", data: mockNotifications }
  },

  // æ ‡è®°å·²è¯»
  async markAsRead(id: string): Promise<ApiResponse<null>> {
    await delay(100)
    const notif = mockNotifications.find((n) => n.id === id)
    if (notif) notif.read = true
    return { code: 200, message: "success", data: null }
  },

  // å…¨éƒ¨å·²è¯»
  async markAllAsRead(): Promise<ApiResponse<null>> {
    await delay(100)
    mockNotifications.forEach((n) => (n.read = true))
    return { code: 200, message: "success", data: null }
  },

  // æ¸…ç©ºé€šçŸ¥
  async clearAll(): Promise<ApiResponse<null>> {
    await delay(100)
    mockNotifications.length = 0
    return { code: 200, message: "success", data: null }
  },
}

// ==================== ç¡¬ä»¶ç›¸å…³æ¥å£ ====================
export const hardwareApi = {
  // è·å–ç¡¬ä»¶çŠ¶æ€
  async getStatus(): Promise<ApiResponse<HardwareStatus>> {
    await delay(100)
    return {
      code: 200,
      message: "success",
      data: {
        wifi: "online",
        ble: "offline",
        zigbee: "warning",
      },
    }
  },

  // é‡è¿ç¡¬ä»¶
  async reconnect(type: "wifi" | "ble" | "zigbee"): Promise<ApiResponse<HardwareStatus>> {
    await delay(1000)
    return {
      code: 200,
      message: "success",
      data: {
        wifi: "online",
        ble: "online",
        zigbee: "online",
      },
    }
  },
}

// ==================== çŸ¥è¯†åº“ç›¸å…³æ¥å£ ====================
export const knowledgeApi = {
  // è·å–åˆ†ç±»åˆ—è¡¨
  async getCategories(): Promise<ApiResponse<KnowledgeCategory[]>> {
    await delay(200)
    return { code: 200, message: "success", data: mockKnowledgeCategories }
  },

  // è·å–æ–‡ç« åˆ—è¡¨
  async getArticles(params?: ArticleListParams): Promise<ApiResponse<PaginatedResponse<Article>>> {
    await delay(300)
    let list = [...mockArticles]

    if (params?.category) {
      list = list.filter((a) => a.category === params.category)
    }
    if (params?.type) {
      list = list.filter((a) => a.type === params.type)
    }
    if (params?.starred) {
      list = list.filter((a) => mockStarredArticles.has(a.id))
    }
    if (params?.keyword) {
      const kw = params.keyword.toLowerCase()
      list = list.filter(
        (a) =>
          a.title.toLowerCase().includes(kw) ||
          a.summary.toLowerCase().includes(kw) ||
          a.tags.some((tag) => tag.toLowerCase().includes(kw)),
      )
    }

    return {
      code: 200,
      message: "success",
      data: {
        list: list.map((a) => ({ ...a, starred: mockStarredArticles.has(a.id) })),
        total: list.length,
        page: params?.page || 1,
        pageSize: params?.pageSize || 10,
      },
    }
  },

  // è·å–æ–‡ç« è¯¦æƒ…
  async getArticleDetail(id: string): Promise<ApiResponse<Article>> {
    await delay(200)
    const article = mockArticles.find((a) => a.id === id)
    if (!article) {
      return { code: 404, message: "æ–‡ç« ä¸å­˜åœ¨", data: null as unknown as Article }
    }
    // å¢åŠ é˜…è¯»é‡
    article.views++
    return {
      code: 200,
      message: "success",
      data: { ...article, starred: mockStarredArticles.has(article.id) },
    }
  },

  // åˆ›å»ºæ–‡ç« 
  async createArticle(data: CreateArticleRequest): Promise<ApiResponse<Article>> {
    await delay(500)
    const newArticle: Article = {
      id: "article-" + Date.now(),
      ...data,
      categoryName:
        mockKnowledgeCategories.flatMap((c) => [c, ...(c.children || [])]).find((c) => c.id === data.category)?.name ||
        data.category,
      views: 0,
      createdAt: new Date().toISOString().split("T")[0],
      updatedAt: new Date().toISOString().split("T")[0],
      author: "å½“å‰ç”¨æˆ·",
      authorId: "user-001",
      starred: false,
    }
    mockArticles.unshift(newArticle)
    return { code: 200, message: "success", data: newArticle }
  },

  // æ›´æ–°æ–‡ç« 
  async updateArticle(data: UpdateArticleRequest): Promise<ApiResponse<Article>> {
    await delay(500)
    const index = mockArticles.findIndex((a) => a.id === data.id)
    if (index === -1) {
      return { code: 404, message: "æ–‡ç« ä¸å­˜åœ¨", data: null as unknown as Article }
    }
    mockArticles[index] = {
      ...mockArticles[index],
      ...data,
      updatedAt: new Date().toISOString().split("T")[0],
    }
    return { code: 200, message: "success", data: mockArticles[index] }
  },

  // åˆ é™¤æ–‡ç« 
  async deleteArticle(id: string): Promise<ApiResponse<null>> {
    await delay(300)
    const index = mockArticles.findIndex((a) => a.id === id)
    if (index !== -1) {
      mockArticles.splice(index, 1)
    }
    return { code: 200, message: "success", data: null }
  },

  // æ”¶è—/å–æ¶ˆæ”¶è—
  async toggleStar(id: string): Promise<ApiResponse<{ starred: boolean }>> {
    await delay(200)
    const isStarred = mockStarredArticles.has(id)
    if (isStarred) {
      mockStarredArticles.delete(id)
    } else {
      mockStarredArticles.add(id)
    }
    return { code: 200, message: "success", data: { starred: !isStarred } }
  },

  // è·å–æ”¶è—åˆ—è¡¨
  async getStarredArticles(): Promise<ApiResponse<string[]>> {
    await delay(100)
    return { code: 200, message: "success", data: Array.from(mockStarredArticles) }
  },

  // è·å–é˜…è¯»å†å²
  async getReadingHistory(): Promise<ApiResponse<ReadingHistory[]>> {
    await delay(200)
    return { code: 200, message: "success", data: mockReadingHistory }
  },

  // æ·»åŠ é˜…è¯»è®°å½•
  async addReadingHistory(articleId: string, articleTitle: string): Promise<ApiResponse<null>> {
    await delay(100)
    // ç§»é™¤å·²å­˜åœ¨çš„è®°å½•
    const existingIndex = mockReadingHistory.findIndex((h) => h.articleId === articleId)
    if (existingIndex !== -1) {
      mockReadingHistory.splice(existingIndex, 1)
    }
    // æ·»åŠ åˆ°æœ€å‰é¢
    mockReadingHistory.unshift({
      articleId,
      articleTitle,
      readAt: new Date().toLocaleString("zh-CN"),
    })
    // åªä¿ç•™æœ€è¿‘20æ¡
    if (mockReadingHistory.length > 20) {
      mockReadingHistory.pop()
    }
    return { code: 200, message: "success", data: null }
  },

  // æœç´¢æ–‡ç« 
  async searchArticles(keyword: string): Promise<ApiResponse<Article[]>> {
    await delay(300)
    const kw = keyword.toLowerCase()
    const results = mockArticles.filter(
      (a) =>
        a.title.toLowerCase().includes(kw) ||
        a.summary.toLowerCase().includes(kw) ||
        a.content.toLowerCase().includes(kw) ||
        a.tags.some((tag) => tag.toLowerCase().includes(kw)),
    )
    return { code: 200, message: "success", data: results }
  },
}

// ==================== å¯¼å‡ºæ‰€æœ‰ API ====================
export * from "./types"

// ==================== å¯¼å‡ºæ‰€æœ‰ API ====================
export * from "./types"
